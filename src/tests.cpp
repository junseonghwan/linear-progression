//
//  tests.cpp
//  lpm
//
//  Created by Seong-Hwan Jun on 2019-01-28.
//

#include "tests.hpp"

#include <cassert>
#include <iostream>
#include <string>

#include <boost/filesystem.hpp>

#include "data_util.hpp"
#include "lpm.hpp"

using namespace std;

// 1. test the likelihood calculation
void test_likelihood()
{
    boost::filesystem::path curr_path = boost::filesystem::current_path();
    cout << "Exec dir: " <<  curr_path.string() << endl;
//    string data_path = curr_path.string() + "/data/test";
    string data_path = "../../data/test";
    string rep_path;
    string gold_standard_file_name;
    string data_file_name;
    string pathway_file_name;
    string param_file_name;
    
    unsigned int n_patients;
    unsigned int n_genes;
    unsigned int n_pathways;
    
    double gold_log_lik;
    double log_lik;
    double fbp, bgp;
    
    size_t idx;

    // free these objects within the loop
    gsl_matrix *data_matrix = 0;
    gsl_matrix *gold = 0;
    unsigned int *true_pathway = 0;

    for (size_t rep = 0; rep < 99; rep++) {
        rep_path = data_path + "/rep" + to_string(rep);
        gold_standard_file_name = rep_path + "/gold_standard.csv";
        data_file_name = rep_path + "/matrix.csv";
        pathway_file_name = rep_path + "/generative_mem_mat.csv";
        param_file_name = rep_path + "/parameters.csv";

        // read the data matrix
        data_matrix = read_data(data_file_name);
        n_genes = data_matrix->size2;

        // read the gold standard likelihood file
        gold = read_csv(gold_standard_file_name, false);

        // read the true pathway
        true_pathway = new unsigned int[n_genes];
        n_pathways = read_ground_truth_pathway_from_matrix(pathway_file_name, true_pathway);
        
        // read the parameters
        read_error_params(param_file_name, fbp, bgp);

        for (idx = 0; idx < gold->size1; idx++) {
            n_patients = gsl_matrix_get(gold, idx, 0);
            gold_log_lik = gsl_matrix_get(gold, idx, 1);

            gsl_matrix_view sub_matrix = gsl_matrix_submatrix(data_matrix, 0, 0, n_patients, n_genes);
            log_lik = compute_likelihood_from_matrix(&sub_matrix.matrix, true_pathway, n_pathways, n_genes, false, fbp, bgp);
            assert(abs(log_lik - gold_log_lik) < TOL);
        }
        
        // free the allocated memory
        delete [] true_pathway;
        delete data_matrix;
        delete gold;
    }
    
    cout << "Likelihood test passed!" << endl;
}

// 2. run importance sampling to estimate the log marginal likelihood
// 3. run SMC to estimate the log marginal likelihood
// 4. check that SMC log marginal likelihood estimate and the one that uses all unique samples generated by SMC converge

int main()
{
    test_likelihood();
    return 0;
}

//bool test_lpm_model_importance_sampling()
//{
//    // for small number of genes and pathway, we can compute the exact value of the marginal likelihood by
//    // enumerating over all possibilities
//    // then, we can check that the marginal likelihood estimate from IS/SMC approaches this value
//
//    double fbp = 0.027;
//    double bgp = 0.1321;
//
//    int n_patients = 3;
//    int n_pathways = 2;
//    int n_genes = 3;
//
//    double y[] = {
//        1, 1, 0,
//        1, 0, 1,
//        1, 1, 1
//    };
//
//    gsl_matrix_view Y = gsl_matrix_view_array(y, n_patients, n_genes);
//    vector<size_t> stages(n_patients, 0);
//    stages[0] = 1;
//    stages[1] = 0;
//    stages[2] = 2;
//
//    // enumerate over possible values of x using 3 for loops
//    double exact_log_lik = DOUBLE_NEG_INF;
//    vector<size_t> pathway_membership(n_genes, 0);
//    for (size_t i = 0; i < n_pathways; i++) {
//        pathway_membership.at(0) = i;
//        for (size_t j = 0; j < n_pathways; j++) {
//            pathway_membership.at(1) = j;
//            for (size_t k = 0; k < n_pathways; k++) {
//                pathway_membership.at(2) = k;
//
//                // convert pathway membership to matrix x
//                double *x = convert_to_array(pathway_membership, n_pathways);
//                gsl_matrix_view X = gsl_matrix_view_array(x, n_genes, n_pathways);
//                double log_val = compute_pathway_likelihood(Y, X, stages, fbp, bgp);
//                exact_log_lik = log_add(exact_log_lik, log_val);
//                cout << "===" << endl;
//                cout << log_val << ", " << exact_log_lik << endl;
//                for (size_t l = 0; l < pathway_membership.size(); l++)
//                    cout << pathway_membership[l] << endl;
//                cout << "===" << endl;
//            }
//        }
//    }
//    exact_log_lik += log(1./8); // multiply by the prior
//    cout << "Exact marginal likelihood: " << exact_log_lik << endl;
//
//    // run importance sampling with proposal from the prior, to get an estimate of the marginal log likelihood
//    SMCOptions smc_options;
//    smc_options.ess_threshold = 1.0;
//    smc_options.num_particles = 100000;
//    smc_options.resample_last_round = false;
//
//    size_t n_smc_iter = 1;
//    bool allocate_passenger_pathway = false;
//    LinearProgressionModel *model = new LinearProgressionModel(n_genes, n_pathways, n_smc_iter, 10, &Y, allocate_passenger_pathway);
//    LinearProgressionParameters params(fbp, bgp);
//    params.set_patient_progression_stages(stages);
//
//    SMC<LinearProgressionState, LinearProgressionParameters> smc(model, &smc_options);
//    smc.run_smc(params);
//    ParticlePopulation<LinearProgressionState> *pop = smc.get_curr_population();
//    double logZ = pop->get_log_norm();
//    cout << "Estimated logZ: " << logZ << endl;
//    if (abs(exp(exact_log_lik) - exp(logZ)) > TOL) {
//        cerr << "Importance sampling estimate is incorrect." << endl;
//        return false;
//    }
//    return true;
//}
//
//bool test_lpm_model_smc()
//{
//    double fbp = 0.027;
//    double bgp = 0.1321;
//
//    int n_patients = 3;
//    int n_pathways = 2;
//    int n_genes = 3;
//
//    double y[] = {
//        1, 1, 0,
//        1, 0, 1,
//        1, 1, 1
//    };
//    gsl_matrix_view Y = gsl_matrix_view_array(y, n_patients, n_genes);
//    vector<size_t> stages(n_patients, 0);
//    stages[0] = 1;
//    stages[1] = 0;
//    stages[2] = 2;
//
//    // enumerate over possible values of x using 3 for loops
//    double exact_log_lik = DOUBLE_NEG_INF;
//    vector<size_t> pathway_membership(n_genes, 0);
//    for (size_t i = 0; i < n_pathways; i++) {
//        pathway_membership.at(0) = i;
//        for (size_t j = 0; j < n_pathways; j++) {
//            pathway_membership.at(1) = j;
//            for (size_t k = 0; k < n_pathways; k++) {
//                pathway_membership.at(2) = k;
//
//                // convert pathway membership to matrix x
//                double *x = convert_to_array(pathway_membership, n_pathways);
//                gsl_matrix_view X = gsl_matrix_view_array(x, n_genes, n_pathways);
//                double log_val = compute_pathway_likelihood(Y, X, stages, fbp, bgp);
//                exact_log_lik = log_add(exact_log_lik, log_val);
//                cout << "===" << endl;
//                cout << log_val << ", " << exact_log_lik << endl;
//                for (size_t l = 0; l < pathway_membership.size(); l++)
//                    cout << pathway_membership[l] << endl;
//                cout << "===" << endl;
//            }
//        }
//    }
//    exact_log_lik += log(1./8);
//    cout << "Exact marginal likelihood: " << exact_log_lik << endl;
//
//    // run importance sampling with proposal from the prior, to get an estimate of the marginal log likelihood
//    SMCOptions smc_options;
//    smc_options.ess_threshold = 0.8;
//    smc_options.num_particles = 2000;
//    smc_options.resample_last_round = false;
//    smc_options.track_population = true;
//    size_t n_smc_iter = 200;
//
//    bool allocate_passenger_pathway = false;
//    LinearProgressionModel *model = new LinearProgressionModel(n_genes, n_pathways, n_smc_iter, 5, &Y, allocate_passenger_pathway);
//    LinearProgressionParameters params(fbp, bgp);
//    params.set_patient_progression_stages(stages);
//
//    SMC<LinearProgressionState, LinearProgressionParameters> smc(model, &smc_options);
//    smc.run_smc(params);
//    double logZ = smc.get_log_marginal_likelihood();
//    cout << "=====" << endl;
//    cout << "Estimated logZ: " << logZ << endl;
//    if (abs(exp(exact_log_lik) - exp(logZ)) > TOL) {
//        cerr << "SMC estimate is incorrect." << endl;
//        return false;
//    }
//    return true;
//}

//void run_tests()
//{
//    if (!test_likelihood1()) {
//        cerr << "Error: likelihood test 1" << endl;
//        exit(-1);
//    }
//    if (!test_likelihood2()) {
//        cerr << "Error: likelihood test 2" << endl;
//        exit(-1);
//    }
//    if (!test_lpm_model_importance_sampling()) {
//        cerr << "Error: importance sampling" << endl;
//        exit(-1);
//    }
//    if (!test_lpm_model_smc()) {
//        cerr << "Error: smc sampler" << endl;
//        exit(-1);
//    }
//}

//bool test_likelihood1()
//{
//    double fbp = 0.072;
//    double bgp = 0.0321;
//
//    int n_patients = 2;
//    int n_pathways = 3;
//    int n_genes = 3;
//
//    double y[] = {
//        1, 0, 1,
//        1, 1, 1,
//    };
//
//    double x[] = {
//        1, 0, 0,
//        0, 1, 0,
//        0, 0, 1,
//    };
//
//    double r[n_patients*n_pathways];
//    int pathway_sizes[] = {1, 1, 1};
//
//    gsl_matrix_view Y = gsl_matrix_view_array(y, n_patients, n_genes);
//    gsl_matrix_view X = gsl_matrix_view_array(x, n_genes, n_pathways);
//    gsl_matrix_view R = gsl_matrix_view_array(r, n_patients, n_pathways);
//
//    /* Compute C = A B */
//    gsl_blas_dgemm (CblasNoTrans, CblasNoTrans,
//                    1.0, &Y.matrix, &X.matrix,
//                    0.0, &R.matrix);
//
//
//    // test likelihood calculation
//    double truth[] = {-3.546249, -0.2241706};
//
//    int stages[] = {0, 2};
//    for (int m = 0; m < n_patients; m++) {
//        double log_lik = 0.0;
//        for (int k = 0; k < n_pathways; k++) {
//            double val = gsl_matrix_get(&R.matrix, m, k);
//            if (k <= stages[m]) {
//                log_lik += compute_log_lik(val, pathway_sizes[k], bgp, fbp);
//            } else {
//                log_lik += compute_log_lik_bg(val, pathway_sizes[k], bgp, fbp);
//            }
//        }
//        if (abs(truth[m] - log_lik) > TOL) {
//            cerr << "Likelihood test 1: error in likelihood computation for sample " << m << endl;
//            cerr << "Expected: " << truth[m] << endl;
//            cerr << "Obtained: " << log_lik << endl;
//            return false;
//        }
//    }
//    cout << "Likelihood test 1 passed!" << endl;
//    return true;
//}
//
//bool test_likelihood2()
//{
//    // simple test:
//    // read in the data
//    // read in the true pathway
//    // compute the likelihood
//
//    double fbp = 0.027;
//    double bgp = 0.1321;
//
//    int n_patients = 3;
//    int n_pathways = 3;
//    int n_genes = 7;
//
//    double y[] = {
//        1, 0, 1, 0, 0, 0, 0,
//        1, 1, 1, 0, 1, 1, 1,
//        0, 0, 1, 1, 0, 0, 0
//    };
//
//    double x[] = {
//        1, 0, 0,
//        1, 0, 0,
//        0, 1, 0,
//        0, 1, 0,
//        0, 1, 0,
//        0, 1, 0,
//        0, 0, 1
//    };
//
//    double r[n_patients*n_pathways];
//    int pathway_sizes[] = {2, 4, 1};
//
//    gsl_matrix_view Y = gsl_matrix_view_array(y, n_patients, n_genes);
//    gsl_matrix_view X = gsl_matrix_view_array(x, n_genes, n_pathways);
//    gsl_matrix_view R = gsl_matrix_view_array(r, n_patients, n_pathways);
//
//    /* Compute C = A B */
//    gsl_blas_dgemm (CblasNoTrans, CblasNoTrans,
//                    1.0, &Y.matrix, &X.matrix,
//                    0.0, &R.matrix);
//
//
//    // test likelihood calculation
//    double truth[] = {-4.21657, -4.503214, -4.839183};
//
//    int stages[] = {2, 2, 1};
//    for (int m = 0; m < n_patients; m++) {
//        double log_lik = 0.0;
//        for (int k = 0; k < n_pathways; k++) {
//            double val = gsl_matrix_get(&R.matrix, m, k);
//            if (k <= stages[m]) {
//                log_lik += compute_log_lik(val, pathway_sizes[k], bgp, fbp);
//            } else {
//                log_lik += compute_log_lik_bg(val, pathway_sizes[k], bgp, fbp);
//            }
//        }
//        if (abs(truth[m] - log_lik) > TOL) {
//            cerr << "Likelihood test 2: error in likelihood computation for sample " << m << endl;
//            cerr << "Expected: " << truth[m] << endl;
//            cerr << "Obtained: " << log_lik << endl;
//            return false;
//        }
//    }
//    cout << "Likelihood test 2 passed!" << endl;
//    return true;
//}
//
//bool test_likelihood3()
//{
//    // simple test:
//    // read in the data
//    // read in the true pathway
//    // compute the likelihood
//
//    double fbp = 0.027;
//    double bgp = 0.1321;
//
//    int n_patients = 1;
//    int n_pathways = 2;
//    int n_genes = 4;
//
//    double y[] = {
//        1, 0, 1, 0
//    };
//
//    vector<double> pathway;
//    pathway.push_back(0);
//    pathway.push_back(0);
//    pathway.push_back(1);
//    pathway.push_back(1);
//
//    double x[] = {
//        1, 0,
//        1, 0,
//        0, 1,
//        0, 1
//    };
//
//    double r[n_patients*n_pathways];
//
//    gsl_matrix_view Y = gsl_matrix_view_array(y, n_patients, n_genes);
//    gsl_matrix_view X = gsl_matrix_view_array(x, n_genes, n_pathways);
//    gsl_matrix_view R = gsl_matrix_view_array(r, n_patients, n_pathways);
//
//    /* Compute C = A B */
//    gsl_blas_dgemm (CblasNoTrans, CblasNoTrans,
//                    1.0, &Y.matrix, &X.matrix,
//                    0.0, &R.matrix);
//
//    LinearProgressionState true_state(n_genes, n_pathways);
//    for (size_t g = 0; g < n_genes; g++) {
//        true_state.update_pathway_membership(g, pathway[g]);
//    }
//
//    LinearProgressionParameters params(fbp, bgp);
//
//    // test likelihood calculation where patient stage is marginalized
//    double truth = -0.2028664;
//    double log_lik = compute_pathway_likelihood(Y, true_state, params);
//    if (abs(truth - log_lik) > TOL) {
//        cerr << "Likelihood test 3: error in the likelihood computation marginalization over stages." << endl;
//        cerr << "Expected: " << truth << endl;
//        cerr << "Obtained: " << log_lik << endl;
//        return false;
//    }
//    return true;
//}
//
//bool test_likelihood4()
//{
//    string data_path = "/Users/seonghwanjun/Dropbox/Research/single-cell-research/repos/LPM/simulated_data/model_selection/npatients20/rep0/";
//    string obs_file_path = data_path + "/dat.csv";
//    string stages_file_path = data_path + "/stages.csv";
//    string gt_file_path = data_path + "/pathways.csv";
//    string param_file_path = data_path + "/params.csv";
//
//    size_t n_patients = 20;
//    size_t n_genes = 25;
//    size_t true_model_length = 5;
//
//    double *obs = read_data(obs_file_path, n_genes, n_patients);
//    gsl_matrix_view obs_matrix_view = gsl_matrix_view_array(obs, n_patients, n_genes);
//    vector<size_t> row_sum(n_patients);
//    compute_row_sum(obs_matrix_view, row_sum);
//    vector<size_t> *stages = read_stages(stages_file_path);
//    vector<size_t> *gt = read_ground_truth(gt_file_path);
//    LinearProgressionState true_state(n_genes, true_model_length, false);
//    for (size_t g = 0; g < gt->size(); g++) {
//        true_state.update_pathway_membership(g, gt->at(g));
//    }
//
//    double fbp = 0.0, bgp = 0.0;
//    read_error_params(param_file_path, fbp, bgp);
//    LinearProgressionParameters true_params(fbp, bgp, *stages);
//    // compute the log-likelihood of the data given the true stages
//    double log_lik = compute_pathway_likelihood(obs_matrix_view, row_sum, true_state, true_params);
//    double log_lik_expected = -256.2;
//    double ret = abs(log_lik - log_lik_expected);
//    cout << log_lik << " - " << log_lik_expected << "=" << ret << endl;
//    if (ret > 1e-3) {
//        return false;
//    }
//
//    LinearProgressionParameters true_params_no_stages(fbp, bgp);
//    // compute the log-likelihood of the data by marginalizing out the stages
//    double log_lik_marginal_stages = compute_pathway_likelihood(obs_matrix_view, row_sum, true_state, true_params_no_stages);
//    double log_lik_marginal_stages_expected = -260.847;
//    ret = abs(log_lik_marginal_stages - log_lik_marginal_stages_expected);
//    cout << log_lik_marginal_stages << " - " << log_lik_marginal_stages_expected << " = " << ret << endl;
//    if (ret > 1e-3) {
//        return false;
//    }
//    return true;
//}
